..  default-domain:: py
..  module:: iocbuilder.modules.epics_device
..  _builder:


Database Builder Support
========================

The IOC builder can be used to create records with EPICS Device device support.
The IOC builder must be initialised appropriately and a little boilerplate is
needed to use this library for database generation.  See for example the example
IOC.  The following Python code can be used to build a database::

    from pkg_resources import require
    require('iocbuilder==3.41')     # Or version as appropriate

    # Configure the IOC builder as we want to use it and load epics_device
    from iocbuilder import ModuleVersion, TemplateRecordNames, ConfigureTemplate
    ConfigureTemplate(record_names = TemplateRecordNames())
    ModuleVersion('epics_device',
        home = os.environ['EPICS_DEVICE'], use_name = False)

    from iocbuilder import *
    from iocbuilder.modules.epics_device.common import *

    # Now create records, eg
    aOut('RECORD', DESC = 'This is a record')

    # Finally write the records, in this case we use a file name argument
    import sys
    WriteRecords(sys.argv[1])

Invoking a Python script of this form will write a valid EPICS database file.


Creating EPICS Records
----------------------

The builder support module loaded above from
:mod:`iocbuilder.modules.epics_device` provides helper functions for creating
EPICS records of each of the eleven basic types.  A particular coding style is
supported by these calls, if the default behaviour is not felt to be appropriate
then records can be created directly by calling the appropriate methods of
:class:`iocbuilder.modules.epics_device.support.EpicsDevice`.

A number of defaults and naming conventions are applied by the functions below.

In Records
~~~~~~~~~~

Input records are created by the following functions.  Processing must be
arranged for each record.  The options are:

* Setting ``SCAN`` to a delay interval and allowing EPICS to trigger processing.
* Setting ``SCAN = 'I/O Intr'`` and calling :func:`trigger_record` from within
  the driver.
* Leaving ``SCAN`` as ``'Passive'`` and ensuring that the record is processed in
  response to ``FLNK`` from some other record.  See blah_ for this.


..  function::
        aIn(name, LOPR=None, HOPR=None, EGU=None, PREC=None, **fields)
        longIn(name, LOPR=None, HOPR=None, EGU=None, **fields)

    For ``ai`` and ``longin`` records the ``MDEL`` field is set by default to -1
    to ensure that all ticks are generated.

..  function:: boolIn(name, ZNAM=None, ONAM=None, **fields)

    For :func:`boolIn` the two optional arguments are the strings associated
    with boolean values ``false`` and ``true`` respectively.

..  function:: mbbIn(name, *option_values, **fields)

    For ``mbbIn`` `*option_values` represents a sequence of up to 16 enumeration
    assignments.  Each assignment is either a string, in which case the default
    numbering assigns ``ZRVL=0``, ``ONVL=1``, etc; or else a tuple of two or
    three values, in which case the first value is the option name, the second
    the associated numerical value, and the third the severity.

    For example::

        status = mbbIn('STATUS',
            'Ok', ('Failing', 1, 'MINOR'), ('Failed', 2, 'MAJOR'),
            DESC = 'Status pv')

    This creates a PV with value 0, 1 or 2, and with increasing severity.

..  function:: stringIn(name, **fields)

    Creates a ``stringin`` record.


Out Records
~~~~~~~~~~~

For all "out" records ``OMSL`` is set to ``supervisory`` and ``PINI`` is set to
``YES``.  As "out" records are normally used for device configuration they
should be left with ``SCAN`` set to ``'Passive'``, the default.

The name passed to each of these functions is the internal address, and
the record name is generated by adding ``_S`` to the given name.

..  function:: aOut(name, DRVL=None, DRVH=None, EGU=None, PREC=None, **fields)
..  function:: longOut(name, DRVL=None, DRVH=None, EGU=None, **fields)

    By default for ``ao`` and ``longout`` records the ``LOPR`` and ``HOPR``
    fields are set equal to ``DRVL`` and ``DRVH`` respectively.

..  function:: boolOut(name, ZNAM=None, ONAM=None, **fields)

    See :func:`boolIn` for the optional arguments.

..  function:: mbbOut(name, *option_values, **fields)

    See :func:`mbbIn` for `option_values`.  An example control PV might be::

        mbbOut('SETUP', 'Normal', 'Unusual', 'Special',
            DESC = 'Configure setup control')

..  function:: stringOut(name, **fields)

    Creates a ``stringout`` record.


Waveform Records
~~~~~~~~~~~~~~~~

For waveform records the direction of data flow is determined by driver support
rather than by EPICS or the device layer.

..  function:: Waveform(name, length, FTVL='LONG', **fields)

    Defines a waveform record with the given `name`.  The number of points in
    the waveform must be specified as `length`, and if a field type other than
    ``'LONG'`` (which really means 32-bit integer) is wanted this must be
    explicitly specified.

..  function:: WaveformOut(name, length, FTVL='LONG', **fields)

    This is used for defining a waveform specialised for output.  Functionally
    this is identicial to :func:`Waveform` except for two differences:

    * The associated record name has ``'_S'`` appended.
    * The ``'PINI'`` field is set to ``'YES'``.


Helper Functions
----------------

These functions are designed to assist in the generation of databases.  The
:func:`Trigger` function is the most complex one, designed for record sets which
update on driver internal events.

..  function:: Trigger(prefix, *pvs)

    This function generates two records with names `prefix`\ ``:TRIG`` and
    `prefix`\ ``:DONE`` together with as many fanout records as necessary to
    ensure that all of the PVs in `pvs` are processed in turn when the ``:TRIG``
    record is processed.  This function is designed to be used with the
    :c:type:`struct epics_interlock` API to implement coherent updating of all
    the linked PVs.

    For example, the database definition::

        Trigger('UPDATE', aIn('V1'), aIn('V2'), aIn('V3'))

    ..  highlight:: c

    can be combined with the following C code to trigger simultaneous and
    coherent updates of the three named PVs::

        static struct epics_interlock *update;
        static double v1, v2, v3;
        static void compute_update(double *v1, double *v2, double *v3) { ... }

        // Called in response to some internal or external action
        void trigger_update_v(void)
        {
            interlock_wait(update);
            compute_update(&v1, &v2, &v3);
            interlock_trigger(update, NULL);
        }

        // Publish the PVs
        void publish_pvs(void)
        {
            update = create_interlock("UPDATE", false);
            PUBLISH_READ_VAR(ai, "V1", v1);
            PUBLISH_READ_VAR(ai, "V2", v2);
            PUBLISH_READ_VAR(ai, "V3", v3);
        }

    ..  highlight:: py

    The key principle here is that the variables containing the values of the
    PVs are only written while the interlock (``update``) is held, so that EPICS
    see a consistent update of all PVs.  This is of particular importance when
    waveforms are involved.

..  function:: Action(name, **fields)

    Creates an "action" PV.  This is a ``bo`` record configured not to start
    during IOC initialisation.

..  function:: ForwardLink(name, desc, *pvs, **fields)

    A helper function for triggering internal processing after any PV in the
    list `pvs` is processed.  Creates an action PV by calling :func:`Action` and
    forward links each passed PV to the new action PV.  The created PV is
    returned.

    This is designed to be used to trigger common processing after any of a set
    of "out" records have been updated.

..  function:: AggregateSeverity(name, description, recs)

    For up to 12 records, passed as list `recs`, generates a ``calc`` record
    with the given name and description with severity set to the aggregated
    severity of the input records.  The value of the generated record is 1.

    The returned record must be processed, typically after processing the given
    list of records.  For example::

        pvs = [
            aIn('PV1', HIGH = 1, HSV = 'MINOR'),
            bIn('PV2', 'Ok', 'Bad', OSV = 'MAJOR')]
        pvs.append(AggregateSeverity('ALL', 'Health', pvs))
        Trigger('UPDATE', *pvs)

    Note that in this example the aggregation PV must be processed after the PVs
    it aggregates.


..  function:: concat(ll)

    A simple helper function to concatenate a list of lists.
